import { Test, TestingModule } from '@nestjs/testing';
import { ResultadosAprendizajeController } from './resultados-aprendizaje.controller';
import { ResultadosAprendizajeService } from './resultados-aprendizaje.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { CreateResultadoAprendizajeDto } from './dto/create-resultado-aprendizaje.dto';
import { FilterResultadoAprendizajeDto } from './dto/filter-resultado-aprendizaje.dto';
import { TipoRA } from './models/resultado-aprendizaje.model';
import { RolEnum } from '../common/enums/rol.enum';

describe('ResultadosAprendizajeController', () => {
  let controller: ResultadosAprendizajeController;
  let service: ResultadosAprendizajeService;

  const mockResultadosAprendizajeService = {
    create: jest.fn(),
    findAllWithFiltersAndPagination: jest.fn(),
  };

  const mockJwtAuthGuard = {
    canActivate: jest.fn(() => true),
  };

  const mockRolesGuard = {
    canActivate: jest.fn(() => true),
  };

  const mockUser = {
    id: 1,
    cedula: '1234567890',
    nombres: 'Juan',
    apellidos: 'PÃ©rez',
    email: 'juan.perez@test.com',
    telefono: '0999999999',
    activo: true,
    carreraId: 1,
    roles: [{ nombre: RolEnum.COORDINADOR }],
  };

  const mockRA = {
    id: 1,
    codigo: 'RA1',
    descripcion: 'Test resultado de aprendizaje',
    tipo: TipoRA.GENERAL,
    carreraId: 1,
    createdAt: new Date('2025-10-13T05:05:36.333Z'),
    updatedAt: new Date('2025-10-13T05:05:36.333Z'),
  };

  const mockPaginatedResponse = {
    data: [mockRA],
    total: 15,
    page: 1,
    limit: 10,
    totalPages: 2,
    hasPrevious: false,
    hasNext: true,
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ResultadosAprendizajeController],
      providers: [
        {
          provide: ResultadosAprendizajeService,
          useValue: mockResultadosAprendizajeService,
        },
      ],
    })
      .overrideGuard(JwtAuthGuard)
      .useValue(mockJwtAuthGuard)
      .overrideGuard(RolesGuard)
      .useValue(mockRolesGuard)
      .compile();

    controller = module.get<ResultadosAprendizajeController>(ResultadosAprendizajeController);
    service = module.get<ResultadosAprendizajeService>(ResultadosAprendizajeService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('create', () => {
    const createDto: CreateResultadoAprendizajeDto = {
      codigo: 'RA1',
      descripcion: 'Test resultado de aprendizaje',
      tipo: TipoRA.GENERAL,
      carreraId: 1,
    };

    it('should create a new RA successfully', async () => {
      mockResultadosAprendizajeService.create.mockResolvedValue(mockRA);

      const result = await controller.create(createDto, mockUser as any);

      expect(mockResultadosAprendizajeService.create).toHaveBeenCalledWith(createDto, mockUser.id);
      expect(result).toEqual({
        id: mockRA.id,
        codigo: mockRA.codigo,
        descripcion: mockRA.descripcion,
        tipo: mockRA.tipo,
        carreraId: mockRA.carreraId,
        createdAt: mockRA.createdAt,
        updatedAt: mockRA.updatedAt,
      });
    });

    it('should create RA without codigo (auto-generated)', async () => {
      const createDtoWithoutCode = { ...createDto };
      delete createDtoWithoutCode.codigo;

      const mockRAAutoGenerated = {
        ...mockRA,
        codigo: 'RA1', // Auto-generated
      };

      mockResultadosAprendizajeService.create.mockResolvedValue(mockRAAutoGenerated);

      const result = await controller.create(createDtoWithoutCode, mockUser as any);

      expect(mockResultadosAprendizajeService.create).toHaveBeenCalledWith(
        createDtoWithoutCode,
        mockUser.id,
      );
      expect(result.codigo).toBe('RA1');
    });

    it('should create RA for ESPECIFICO type', async () => {
      const createDtoEspecifico = {
        ...createDto,
        codigo: 'RAE1',
        tipo: TipoRA.ESPECIFICO,
      };

      const mockRAEspecifico = {
        ...mockRA,
        codigo: 'RAE1',
        tipo: TipoRA.ESPECIFICO,
      };

      mockResultadosAprendizajeService.create.mockResolvedValue(mockRAEspecifico);

      const result = await controller.create(createDtoEspecifico, mockUser as any);

      expect(result.tipo).toBe(TipoRA.ESPECIFICO);
      expect(result.codigo).toBe('RAE1');
    });

    it('should handle service errors', async () => {
      const error = new Error('Service error');
      mockResultadosAprendizajeService.create.mockRejectedValue(error);

      await expect(controller.create(createDto, mockUser as any)).rejects.toThrow('Service error');
    });
  });

  describe('findAll', () => {
    it('should return paginated RAs with default filters', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        page: 1,
        limit: 10,
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue(
        mockPaginatedResponse,
      );

      const result = await controller.findAll(filterDto);

      expect(mockResultadosAprendizajeService.findAllWithFiltersAndPagination).toHaveBeenCalledWith(
        filterDto,
      );
      expect(result).toEqual({
        data: [
          {
            id: mockRA.id,
            codigo: mockRA.codigo,
            descripcion: mockRA.descripcion,
            tipo: mockRA.tipo,
            carreraId: mockRA.carreraId,
            createdAt: mockRA.createdAt,
            updatedAt: mockRA.updatedAt,
          },
        ],
        total: 15,
        page: 1,
        limit: 10,
        totalPages: 2,
        hasPrevious: false,
        hasNext: true,
      });
    });

    it('should return RAs filtered by tipo GENERAL', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        tipo: TipoRA.GENERAL,
        page: 1,
        limit: 10,
      };

      const generalRAResponse = {
        ...mockPaginatedResponse,
        data: [mockRA],
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue(
        generalRAResponse,
      );

      const result = await controller.findAll(filterDto);

      expect(mockResultadosAprendizajeService.findAllWithFiltersAndPagination).toHaveBeenCalledWith(
        filterDto,
      );
      expect(result.data[0].tipo).toBe(TipoRA.GENERAL);
    });

    it('should return RAs filtered by tipo ESPECIFICO', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        tipo: TipoRA.ESPECIFICO,
        page: 1,
        limit: 5,
      };

      const mockRAEspecifico = {
        ...mockRA,
        codigo: 'RAE1',
        tipo: TipoRA.ESPECIFICO,
      };

      const especificoRAResponse = {
        ...mockPaginatedResponse,
        data: [mockRAEspecifico],
        limit: 5,
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue(
        especificoRAResponse,
      );

      const result = await controller.findAll(filterDto);

      expect(result.data[0].tipo).toBe(TipoRA.ESPECIFICO);
      expect(result.data[0].codigo).toBe('RAE1');
      expect(result.limit).toBe(5);
    });

    it('should return RAs filtered by codigo', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        codigo: 'RA1',
        page: 1,
        limit: 10,
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue({
        ...mockPaginatedResponse,
        total: 1,
        totalPages: 1,
        hasNext: false,
      });

      const result = await controller.findAll(filterDto);

      expect(mockResultadosAprendizajeService.findAllWithFiltersAndPagination).toHaveBeenCalledWith(
        filterDto,
      );
      expect(result.total).toBe(1);
      expect(result.hasNext).toBe(false);
    });

    it('should return RAs filtered by descripcion', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        descripcion: 'herramientas',
        page: 1,
        limit: 10,
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue(
        mockPaginatedResponse,
      );

      const result = await controller.findAll(filterDto);

      expect(mockResultadosAprendizajeService.findAllWithFiltersAndPagination).toHaveBeenCalledWith(
        filterDto,
      );
      expect(result).toBeDefined();
    });

    it('should return RAs with search parameter', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        search: 'desarrollo',
        page: 1,
        limit: 10,
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue({
        ...mockPaginatedResponse,
        total: 3,
        totalPages: 1,
        hasNext: false,
      });

      const result = await controller.findAll(filterDto);

      expect(mockResultadosAprendizajeService.findAllWithFiltersAndPagination).toHaveBeenCalledWith(
        filterDto,
      );
      expect(result.total).toBe(3);
    });

    it('should return RAs with carreraId filter', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        carreraId: 1,
        page: 1,
        limit: 10,
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue(
        mockPaginatedResponse,
      );

      const result = await controller.findAll(filterDto);

      expect(mockResultadosAprendizajeService.findAllWithFiltersAndPagination).toHaveBeenCalledWith(
        filterDto,
      );
      expect(result.data[0].carreraId).toBe(1);
    });

    it('should handle pagination navigation - page 2', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        page: 2,
        limit: 5,
      };

      const page2Response = {
        data: [mockRA],
        total: 12,
        page: 2,
        limit: 5,
        totalPages: 3,
        hasPrevious: true,
        hasNext: true,
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue(
        page2Response,
      );

      const result = await controller.findAll(filterDto);

      expect(result.page).toBe(2);
      expect(result.hasPrevious).toBe(true);
      expect(result.hasNext).toBe(true);
      expect(result.totalPages).toBe(3);
    });

    it('should handle combined filters', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        codigo: 'RA',
        tipo: TipoRA.GENERAL,
        descripcion: 'herramientas',
        carreraId: 1,
        page: 1,
        limit: 20,
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue({
        data: [mockRA],
        total: 2,
        page: 1,
        limit: 20,
        totalPages: 1,
        hasPrevious: false,
        hasNext: false,
      });

      const result = await controller.findAll(filterDto);

      expect(mockResultadosAprendizajeService.findAllWithFiltersAndPagination).toHaveBeenCalledWith(
        filterDto,
      );
      expect(result.total).toBe(2);
      expect(result.limit).toBe(20);
    });

    it('should handle empty results', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        codigo: 'NONEXISTENT',
        page: 1,
        limit: 10,
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue({
        data: [],
        total: 0,
        page: 1,
        limit: 10,
        totalPages: 0,
        hasPrevious: false,
        hasNext: false,
      });

      const result = await controller.findAll(filterDto);

      expect(result.data).toEqual([]);
      expect(result.total).toBe(0);
    });

    it('should handle service errors in findAll', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        page: 1,
        limit: 10,
      };

      const error = new Error('Database connection error');
      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockRejectedValue(error);

      await expect(controller.findAll(filterDto)).rejects.toThrow('Database connection error');
    });
  });

  describe('Guards and Decorators', () => {
    it('should have JwtAuthGuard applied', () => {
      const guards = Reflect.getMetadata('__guards__', ResultadosAprendizajeController);
      expect(guards).toBeDefined();
    });

    it('should have RolesGuard applied', () => {
      const guards = Reflect.getMetadata('__guards__', ResultadosAprendizajeController);
      expect(guards).toBeDefined();
    });

    it('should have correct roles for create method', () => {
      const roles = Reflect.getMetadata('roles', controller.create);
      expect(roles).toContain(RolEnum.COORDINADOR);
      expect(roles).toContain(RolEnum.CEI);
    });

    it('should have correct roles for findAll method', () => {
      const roles = Reflect.getMetadata('roles', controller.findAll);
      expect(roles).toContain(RolEnum.COORDINADOR);
      expect(roles).toContain(RolEnum.CEI);
      expect(roles).toContain(RolEnum.PROFESOR);
    });
  });

  describe('Response Format Validation', () => {
    it('should return correctly formatted create response', async () => {
      const createDto: CreateResultadoAprendizajeDto = {
        descripcion: 'Test RA',
        tipo: TipoRA.GENERAL,
        carreraId: 1,
      };

      mockResultadosAprendizajeService.create.mockResolvedValue(mockRA);

      const result = await controller.create(createDto, mockUser as any);

      expect(result).toHaveProperty('id');
      expect(result).toHaveProperty('codigo');
      expect(result).toHaveProperty('descripcion');
      expect(result).toHaveProperty('tipo');
      expect(result).toHaveProperty('carreraId');
      expect(result).toHaveProperty('createdAt');
      expect(result).toHaveProperty('updatedAt');
    });

    it('should return correctly formatted findAll response', async () => {
      const filterDto: FilterResultadoAprendizajeDto = {
        page: 1,
        limit: 10,
      };

      mockResultadosAprendizajeService.findAllWithFiltersAndPagination.mockResolvedValue(
        mockPaginatedResponse,
      );

      const result = await controller.findAll(filterDto);

      expect(result).toHaveProperty('data');
      expect(result).toHaveProperty('total');
      expect(result).toHaveProperty('page');
      expect(result).toHaveProperty('limit');
      expect(result).toHaveProperty('totalPages');
      expect(result).toHaveProperty('hasPrevious');
      expect(result).toHaveProperty('hasNext');

      expect(Array.isArray(result.data)).toBe(true);
      if (result.data.length > 0) {
        const firstItem = result.data[0];
        expect(firstItem).toHaveProperty('id');
        expect(firstItem).toHaveProperty('codigo');
        expect(firstItem).toHaveProperty('descripcion');
        expect(firstItem).toHaveProperty('tipo');
        expect(firstItem).toHaveProperty('carreraId');
      }
    });
  });
});